{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Report on the BBS System project\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Project history\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 8th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Work on the BBS System web app project began on this date.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The root folder, {\f1 bbs-system}, was created.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A mongodb database, {\f1 documents}, was intialised through the Mongodb Compass Community GUI.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A backend folder and a frontend folder were created, and {\f1 npm init} run in both. The ExpressJS CLI and Angular CLI were installed through {\f1 npm install}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The backend was scaffolded through the ExpressJS CLI ({\f1 express --view pug bbs-system-backend}). The frontend was scaffolded through the Angular CLI ({\f1 ng new bbs-system-frontend}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 bbs-system} folder was initialised as a git repo ({\f1 git init}) and as a Visual Studio Code workspace (VS Code GUI. The intial Git commit was performed ({\f1 git add . ; git commit}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 9th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The first lines of project code were authored on this date. The login and signup page was implemented on the Angualar frontend, and the corresponding backend code on the Express backend.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The two parts communicated through a well-defined API. The API was exposed through ExpressJS router on the backend, with endpoints stored in the {\f1 routes} folder. The frontend interacted with it through an Angular service, {\f1 api.service.ts}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The app at this stage was quite minimal, with the login and signup pages missing features such as validation of data, error handling, reCaptcha and email verification. The database was configured, with collections created and indexed. Code was written in the backend to interface with the database.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 10th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It became possible to submit content to the databse, with the first iteration of the posting feature implemented. At this point there was no implementation of subforums; rather all posts were made to a single central board.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The codebase was refactored to remove the placeholder code from the automated scaffolding.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The user profiles feature was scaffolded.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 11th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The user profiles API was implemented on the backend, with routes defined corresponding to the API endpoints. The API-handling code was then written in the API service. After this the UI code for the profile page component was written, communicating with the API through the API service.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It is important in a single-page application (SPA) we maintain a seperation between the backend and frontend code. The two parts of the codebase must be written as self-contained programs that can run independently of each other, communicating through an API.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It is also important that code handling features that must be provided throughout the app, such as client-side storage, network access, and recording program state, be decoupled from the stateless UI code.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This is done by seperating such features into \u8220"services\u8221", which are then injected into UI-handling \u8220"components\u8221" that require them through the Angular dependency injection system.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This practice promotes code reuse and separation of concerns.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Basic CSS styling was also implemented.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 12th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Commenting on posts was implemented. This required significant modifcations to the database structure. As mongodb is a schemaless database, no modification of existing documents was required; only application code needed to be changed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Pagination of comments and posts was implemented. Pagination of long lists is important, as it keeps data retrieval times from increasing with list length and reduces the retrieval of unnecessary data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The scaffolding for data validation and sanitisation was done on the backend. The frontend cannot be trusted with such tasks, as an attacker may modify frontend code or directly communicate with API endpoints.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Data validation should still be implemented on the frontend to inform the user of invalid data without necessitating network communication, but upon data submission must be repeated on the backend.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Password confirmation was also implemented on the signup page, as an Angualr. This is used so that the user doesn\u8217't mistype their password when setting it, and find themselves unable to log in.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 15th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captchas were implemented, using Google\u8217's reCaptcha service. Captchas are useful to prevent automated attacks, i.e.\u160?to deter spambots from creating accounts and spamming the site.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Email verification was implemented. This is used to verify that the email account entered on the signup page actually belongs to the client.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Email verification was implemented using the {\f1 nodemailer} module. It is a good idea to delegate features to external libraries or modules if possible, to save programmer time and take advantage of a well-tested and mature codebase.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The application was changed to use JSON Web Tokens (JWTs) for user authentication. JWTs are a form of stateless session management. The backend issues a digitally signed JSON-serialised object, its structure defined by the JWT standard. The frontend stores this and sends it to the backend whenever authentication is required. The backend uses its private or secret key to verify it was indeed issued by the backend.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The JWT can store an expiry date and other claims, which can be read by the backend and frontend and verified by verifying the signature on the JWT.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 16th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The JWT stored a username claim, which the frontend used to find out the username of the current user.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Post comment pages are handled through a post ID associated with every post, derived from the {\f1 post._id} field in the corresponding database collection. Creating a new post by sending an HTTP {\f1 POST} request to the {\f1 /api/post} endpoint returns the {\f1 post._id}, which the backend uses to link tot he comments page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Resending verification emails was implemented. This is important so that the user can still verify their account if the email is deleted or otherwise lost.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Client-side access control was implemented using Angular Guards. This is not to be used as a security feature. Rather, it is to improve the user experience (UX).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Passing of errors from the backend and the frontend was implemented. It is important to handle errors, as application crashes or misbehaviours are detrimental to the UX.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It is also important to notify the user of errors, as silent failures are also detrimental to the US.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 July 17th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Server-side validation of user-submitted data was implemented.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Profile pictures were implemented. For convenience they were sotred as base64 encoded strings in the database. A file size of 100x100px was specified.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For files larger than 16 MB GridFS can be used to store them in MongoDB, or they can be stored as file paths with the actual files residing in the filesystem.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Caching of HTTP GET requests was scaffolded as an Angular HttpInterceptor. Although the results of HTTP GET requests are already cached in the browser, the requests themselves are not, resulting in errors when attempting to GET data from the server while offline.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 True offline capability could be provided by implementing the application as a Progressive Web App (PWA), using Service Workers to serve the app while offline.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Refactoring of independent UI features into distinct components was conducted.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 18th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The caching HttpInterceptor war implemented. It stores the most recent GET request to a resource and returns its result as the server response when the client is offline.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The error-handling code on the backend was modifed to return the correct HTTP status code to the client in the event of an error. Usage of standard HTTP features is part of designing a RESTful API.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 19th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The frontend was modified to make use of the HTTP status code returned by the server in client-side error-handling.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The application was changed to provide the JWT in the {\f1 Authorisation} header of an HTTP request, using the {\f1 Bearer} token scheme.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The API was changed to be a stateless REST maturity level 2 API.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 22nd, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Implemented subforums in the web application. Subforums contained an array of posts, which themselves contained an array of comments. Subforums used a {\f1 [type].[name]} naming scheme. Implemented posting to user profiles.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Posting to user profiles was modelled through subforums with the format {\f1 user.[username]}. Other subforums used the {\f1 main.[forumname]} name format.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 23rd, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Implemented user creation of subforums. Only {\f1 main.[forumname]} subforums can be created by a user; others cannot. Signup automatically creates a corresponding {\f1 user.[username]} subforums, to serve as the profile subforum to which profile posts are posted.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Tabbing of subforums was implemented.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 In an SPA, the traditional solution of a user opening different subforums in different tabs is undesirable. Instead, tabbing is implemented in the app.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Instead, the app maintains a list of opened subforums and displays them as tabs in the navigation menu. These are stored in and retrieved from {\f1 sessionStorage}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 24th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Along with the list of subforum names the app stores a list of scroll positions. When a subforum tab is navigated to its scroll position is automatically restored.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 25th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Implemented private messaging.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Private messaging must be real-time and biderectional. For this HTTP is inadequate, as under HTTP the server can only respond to requests the client makes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Instead we use the WebSocket protocol, which allows for the server to push data to the client. For a mature and featureful solution to this we turn to the Socket.IO framework.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Our initial implementation of private messaging was minimal, having a single central room to which all messages were directed and to which all clients lsitened. No storage of messages was yet implemented.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 26th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Private messaging was refactored to be person-to-person, with every pair of users messaging each other in a different room with a name derived from their usernames.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Messages were stored in the database, from which the message history of a conversation could be retrieved.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Pagination of messages was implemented, as was validation of user input and error-handling. Reconnection handling was implemented, with the client and server reconnecting after an interruption in the connection.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 29th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The friends list was implemented on the backend and the frontend API service.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The friends list allowed users to send friend requests to other users, which they could cancel. The receiving user would have the choice of accepting or rejecting the request. A user could also delete users from their friends list.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 30th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The friends list UI was implemented on the front end and integrated with the API service.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The messenger only allowed for messaging users on one\u8217's friends list.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The code handling navigation between tabs and scroll location persistance had become quite tangled. It existed in three different areas, the navigation component, the posts-page component and the storage service, with complex interactions in between.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 It was refactored for simplicity and maintainability. The logic controlling scroll persistence was moved to reside only in the posts-page component, with the navigation component handling inter-tab navigation and the storage service, {\f1 storage.service.ts}, handling saving tab information to {\f1 localStorage}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 31th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The scroll persistance was subject to a race condition, wherein the component would scroll to the stored position before the list of posts had been loaded. This caused the final scroll position to not match what it had been when the user navigated away from the page.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To resolve this the posts-page component would track the loading of the posts component, which itself would track the laoding of the post component instances the list of posts was modelled as.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Only once the event signalling the completion of loading propagated up to the posts-page component would the page be scrolled to the retrieved position.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 August 1st, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 An issue with the messenger component was that the messenger state was lost whenever the user navigated away from it.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 To resolve this the messenger state was moved to the messenger service, {\f1 messenger.service.ts}. The messenger component would display the state exposed to it by the messenger service. It would also subscribe to the error observable and perform any necessary error-handling tasks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This was necessary as Angular services should not perform UI tasks such as redirecting to other pages or displaying alerts. Rather, they should act as background utilities.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As a consequence of this the client-side application code could continue to receive information from the server, even when the user had navigated away from the messenger page and thereby the messenger component had been destroyed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A typing indicator was implemented. Typing would produce a typing indicator on the messenger page of the other user connected to a room, which would disappear with a pause in typing.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 2nd, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 File uploads were implemented, using the multer module to handle multipart form data. Users could upload files to the server by sending a {\f1 POST} request to the {\f1 /api/files} endpoint, receiving the filename in response.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A filesize limit of 2MB was enforced, with file types limited to {\f1 .png} files. The files were stored in an {\f1 /uploads/} directory.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Message attachments were implemented as including the filename from the {\f1 POST} request response as a field in the message. Upon receipt of a message with a non-{\f1 null} {\f1 message.filename} the messenger automatically fetched it from the server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 July 5th, 2019\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The default multer-provided algorithm for detemrining a unique filename was replaced, allowing files to be stored with the correct {\f1 .png} extensions. The {\f1 Accept} header of the HTTP request and the {\f1 Content-Type} header of the HTTP response were changed to the {\f1 image/png} MIME type. The {\f1 mime} module was used on the backend to map file extensions to MIME types.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Messages were displayed as small, 100x100px thumbnail-style images on the messenger page, although actual thumbnails with reduced file size were not implemented. Clicking it would display the image on its own in a new tab, at full size.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Build and development instructions\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Make sure Git, npm, Node.js, and MongoDB are present on your system. Clone the {\f1 bbs-system} repository using git. Issue the {\f1 npm install} command in the {\f1 bbs-system-backend} and {\f1 bbs-system-frontend} directories to install the project dependencies.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A start script, {\field{\*\fldinst{HYPERLINK "./start.bat"}}{\fldrslt{\ul
start.bat
}}}
 is located in the program root directory. It may be used to start the application for development on Windows. Alternatively, the following platform-agnostic steps can be followed.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Issue the {\f1 mongod} command to start the database server. It will by default broadcast on {\field{\*\fldinst{HYPERLINK "http://localhost:27017"}}{\fldrslt{\ul
localhost:27017
}}}
. Issue the {\f1 npm start} command in the {\f1 bbs-system-backend} folder to start the backend server. It will by default broadcast on localhost:3200. Issue the {\f1 ng serve} command in the {\f1 bbs-system-frontend} folder to start the frontend testing server. It will by default broadcast on {\field{\*\fldinst{HYPERLINK "http://localhost:4200"}}{\fldrslt{\ul
localhost:4200
}}}
.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Alternatively, issueing the {\f1 ng build --prod} command will build the frontend application for deployment somewhere other than the testing server, configured for production.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Navigate to {\field{\*\fldinst{HYPERLINK "http://127.0.0.1:4200"}}{\fldrslt{\ul
http://127.0.0.1:4200
}}}
 to view the application frontend. You will need to disable your browser\u8217's CORS protections for the frontend application code to be able to communicate with the backend.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 For Chrome on Windows these tasks can be done by running the following command in {\f1 cmd.exe}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 start chrome.exe http://127.0.0.1:4200 --user-data-dir="C:/Chrome dev session" --disable-web-security\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Using 127.0.0.1 instead of localhost is necessary because Google\u8217's reCaptcha service does not support localhost URLs.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The backend server port, frontend FQDN and CORS whitelisted origins can be configured on the backend in the {\field{\*\fldinst{HYPERLINK "./bbs-system-backend/config.json"}}{\fldrslt{\ul
config.json
}}}
 file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Configuration of the application on the frontend is not currently fully implemented. Changing the reCaptcha site key or the backend server FQDN will require changing hardcoded values in multiple places in the frontend application code.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 API documentation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 JWT endpoints\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Endpoints marked as JWT require JWT authentication to use. The JWT is provided in the {\f1 Authorization} request header using the {\f1 Bearer} token scheme. The JWT is issued by the server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 POSTing to /api/login or /api/signup returns a JWT with a {\f1 username} claim. Email verification links require a JWT with a {\f1 username} and an {\f1 emailed} claim.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Captcha endpoints\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha endpoints require a captcha to be completed to be used. The JSON-encoded request body should be of the format {\f1 \{ captchaResponse: ..., ... \}}, where {\f1 captchaResponse} contains the reCaptcha widget response.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Endpoints list\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/account/email\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 POST /api/account/email\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username, emailed\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: Uses a JWT with an {\f1 emailed} claim set to {\f1 true}, issued only for email varification.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Resends email verification link.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/account/profile\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 GET /api/account/profile\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{ body: \{\line
  profile: \{\line
    profileText: ..., //string\line
    profileImage: ... //base64 image/png\line
  \},\line
  verified: ..., //boolean\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: null Usage: Returns profile data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 PUT /api/account/profile\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  profile: \{\line
    profileText: ..., //string\line
    profileImage: ... //base64 image/png\line
  \}\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: Profile image must be 100x100px {\f1 image/png} file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Sets profile data.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/friends/accepted\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 GET /api/friends/accepted\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: {\f1 username} query param indicates user queried.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Returns whether queried user is in friends list.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 DELETE /api/friends/accepted\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: {\f1 username} query param indicates user queried.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Deletes queried user from friends list.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/comment\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 GET /api/comment\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: PostID, position, limit, listingID\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: {\f1 PostID} query param indicates post comments retrieved from. {\f1 position} query param indicates position in list, used for pagination. {\f1 limit} query param indicates number of comments to retrieved, used for pagination. {\f1 listingID} query param indicates name of subforum post is in.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Gets section of list of comments on post.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 POST /api/comment\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: PostID, listingID\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  body: ... // string\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: {\f1 PostID} query param indicates post comment posted to. {\f1 listingID} query param indicates name of subforum post is in. {\f1 body} JSON field indicates text of comment.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Posts comment to post.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/post\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 GET /api/post\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: position, limit, listingID\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: {\f1 position} query param indicates position in list, used for pagination. {\f1 limit} query param indicates number of posts to retrieved, used for pagination. {\f1 listingID} query param indicates name of subforum post is in.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Gets section of list of posts in subforum.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 POST /api/post\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: listingID\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  body: ... // string\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  body: id // string\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: {\f1 listingID} query param indicates name of subforum post is to be posted to. {\f1 body} JSON field indicates ID of created post.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Posts post to subforum.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 GET /api/files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: filename\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: binary blob\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: {\f1 filename} query parameter indicates name of file to get. Response will be binary blob encoding {\f1 image/png} file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Gets user-uploaded file from server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 POST /api/files\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: {\f1 multipart/form-data} file\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: string\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: 2MB file size limit. File should be in {\f1 image/png} format to be displayed correctly. Response will be filename of uploaded file.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Uploads file to server.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/forums\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 POST /api/forums\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: username\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  listingID: ..., // string\line
  description: ... // string\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: {\f1 listingID} request body field indicates subforum name. {\f1 description} request body field indicates subforum description. Subforum names must use the {\f1 main.[forumname]} format.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Creates subforum.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/login\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 POST /api/login\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: Authorization (Basic)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  body: token // string\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: Username and password provided in the {\f1 Authorization} header using the {\f1 Basic} scheme.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT returned as {\f1 body} field of response body.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT has {\f1 username} claim defined, conferring access to auth-requiring endpoints other than {\f1 /api/account/email}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Logs user in, returning JWT.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 /api/signup\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs20 POST /api/signup\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT: No\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Captcha: Yes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Query parameters: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 JWT claims required: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Other headers: null\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Request body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  credentials: \{\line
    username: ..., // string\line
    password: ..., // string\line
    email: ... // string\line
  \}\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Response body:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  body: token // string\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notes: Account credentials provided in the {\f1 credentials} field of the request body. JWT returned as {\f1 body} field of response body. JWT has {\f1 username} claim defined, conferring access to auth-requiring endpoints other than {\f1 /api/account/email}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usage: Creates user account, returning JWT.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sockets API\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Socket.IO is used for the real-time messaging service. The default path of \u8216'/socket.io\u8217' is used\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Upon connection establishment the client should emit the {\f1 listen} event, authenticating themselves for room access. They should then emit the {\f1 joinConversation} event to join a conversation room.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 sendMessages} event should be used to send messages. The client should listen for the {\f1 messages} event to receive messages; {\f1 getMessages} should only be used to read message history, not as some kind of real-time polling mechanism.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Ordering messages with regards to age is the responsibility of the client; for this purpose a {\f1 timestamp} field is included in each message.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 listen\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Takes JWT with {\f1 username} claim as argument and authenticates user.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Should be emitted whenever the {\f1 connection} event is.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 joinConversation\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Takes username of user client requests to chat with as argument.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Should be emitted whenever the client requests to join a conversation with a user.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Joining a conversation is required to send and receive events related to it. A conversation with a user can only be joined if the username is in the client\u8217's friends list. A client may be in only one conversation at a time. Joined rooms are cleared upon disconnection.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 messages\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Given list of messages as argument. Emitted by the server whenever messages are to be sent to a client.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 This may be emitted if the client is sent a message by another client. It may also be emitted as the result of the client emitting the {\f1 getMessages} event. The message list of a message event is ordered by timestamp, but message events may not be emitted in order.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 getMessages\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Takes a location object as argument. The location object has the following structure.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  position: ..., // number\line
  limit: ... // number\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Position specifies an offset from the latest message, at which to retrieve messages. Limit specifies how many messages to retrieve. This is used for retrieval of past messages.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Emission of a {\f1 getMessages} event by the client results in the server emitting a {\f1 messages} event with the specified messages.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs24 sendMessages\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Takes a message object as argument. The message object has the following structure.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 \{\line
  timestamp: ..., // number\line
  from: ..., // string\line
  body: ..., // string\line
  filename: ... // string\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 The {\f1 timestamp} field does not determine the timestamp of the stored message; it is overwritten by the server with the server-determined timestamp upon receipt.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Emission of a {\f1 sendMessage} event by the client results in the server emitting a {\f1 messages} event containing the message in its associated messages array.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Although currently an independent {\f1 messages} event is emitted for each {\f1 sendMessage} event, with a singleton messages array containing the message, this behaviour is subject to change and should not be relied upon.\par}
}
